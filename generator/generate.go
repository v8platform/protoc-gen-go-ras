package generator

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"log"
	"os"
	"strings"
)

// Object is an interface abstracting the abilities shared by enums, messages, extensions and imported objects.
type Object struct {
	protogen.GoIdent
	File      *protogen.File
	TypeIdent protogen.GoIdent
}

type Generator struct {
	plugin           *protogen.Plugin
	typeNameToObject map[string]Object
	enumNameToObject map[string]Object
	enumToObject     map[string]Object
	parseFuncName    string
	formatFuncName   string
}

func NewGenerator(plugin *protogen.Plugin) *Generator {

	gen := &Generator{
		plugin:         plugin,
		parseFuncName:  "Parse",
		formatFuncName: "Formatter",
	}
	gen.BuildTypeNameMap()
	gen.BuildEnumNameMap()
	gen.BuildEnumToObjectMap()
	// log.Println("types", gen.typeNameToObject)

	return gen
}

func (gen *Generator) BuildTypeNameMap() {
	gen.typeNameToObject = make(map[string]Object)
	for _, f := range gen.plugin.Files {
		dottedPkg := "." + string(f.Proto.GetPackage())

		if dottedPkg != "." {
			dottedPkg += "."
		}

		for _, enum := range f.Enums {
			name := dottedPkg + enum.GoIdent.GoName

			//log.Println("Add enum", name)

			gen.typeNameToObject[name] = Object{
				GoIdent: enum.GoIdent,
				File:    f,
			}
		}
		for _, desc := range f.Messages {
			name := dottedPkg + desc.GoIdent.GoName
			//log.Println("Add message", name, desc.GoIdent.String())

			gen.typeNameToObject[name] = Object{
				GoIdent: desc.GoIdent,
				File:    f,
			}
		}
	}
}

func (gen *Generator) BuildEnumToObjectMap() {
	gen.enumToObject = make(map[string]Object)
	for _, f := range gen.plugin.Files {

		for _, message := range f.Messages {

			messageExtension := GetMessageExtensionFor(message.Desc.Options())

			if messageExtension == nil {
				continue
			}

			typeName, _ := messageExtension.GetTypeOption()

			gen.enumToObject[typeName] = Object{
				GoIdent: message.GoIdent,
				File:    f,
			}
		}
	}
}

func (gen *Generator) BuildEnumNameMap() {
	gen.enumNameToObject = make(map[string]Object)
	for _, f := range gen.plugin.Files {

		for _, enum := range f.Enums {

			for _, enumValue := range enum.Values {
				name := string(enumValue.Desc.Name())

				//log.Println("Add enum by name", name)

				gen.enumNameToObject[name] = Object{
					GoIdent:   enumValue.GoIdent,
					File:      f,
					TypeIdent: enumValue.Parent.GoIdent,
				}
			}
		}
	}
}

// dottedSlice turns a sliced name into a dotted name.
func dottedSlice(elem []string) string { return strings.Join(elem, ".") }

func (gen *Generator) ObjectNamed(typeName string) Object {

	if !strings.HasPrefix(typeName, ".") {
		typeName = "." + typeName
	}
	o, ok := gen.typeNameToObject[typeName]
	if !ok {
		gen.Fail("can't find object with type", typeName)
	}
	return o
}

func (gen *Generator) EnumNamed(typeName string) Object {

	o, ok := gen.enumNameToObject[typeName]
	if !ok {
		gen.Fail("can't find object with enum name", typeName)
	}
	return o
}

const (
	// contextPkg         = protogen.GoImportPath("context")
	// encoderPackage    = protogen.GoImportPath("github.com/v8platform/encoder/ras")
	// errPkg             = protogen.GoImportPath("errors")

	deprecationComment = "// Deprecated: Do not use."
)

func (gen *Generator) GenerateFile(plugin *protogen.Plugin, file *protogen.File) {

	filename := file.GeneratedFilenamePrefix + "_ras.pb.go"

	// log.Printf("Processing %s", file.na)
	log.Printf("Generating %s\n", fmt.Sprintf("%s_ras.pb.go", file.GeneratedFilenamePrefix))

	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	g.Skip()
	g.P("// Code generated by github.com/v8platform/protoc-gen-go-ras. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the v8platform/protoc-gen-go-ras ras it is being compiled against.")
	// g.P("// ", contextPkg.Ident(""),  errPkg.Ident(""))
	g.P("// ", encoderPackage.Ident(""), ioPackage.Ident(""))
	g.P()

	for _, enum := range file.Enums {
		gen.generateEnum(g, enum)
	}

	for _, message := range file.Messages {
		//log.Println(message)
		gen.genMessage(g, message)
	}

}

// Fail reports a problem and exits the program.
func (gen *Generator) Fail(msgs ...string) {
	s := strings.Join(msgs, " ")
	log.Print("protoc-gen-go-ras: error:", s)
	os.Exit(1)
}

// Error reports a problem, including an error, and exits the program.
func (gen *Generator) Error(err error, msgs ...string) {
	s := strings.Join(msgs, " ") + ":" + err.Error()
	log.Print("protoc-gen-go-ras: error:", s)
	os.Exit(1)
}

func (gen *Generator) genMessage(g *protogen.GeneratedFile, m *protogen.Message) {

	ext := GetMessageExtensionFor(m.Desc.Options())

	if ext != nil {

		if ext.GetType() != nil {
			enumName, typeOption := ext.GetTypeOption()
			enumIdent := gen.EnumNamed(enumName)
			enumTypeIdent := enumIdent.TypeIdent
			var funcName string
			switch typeOption {
			case "packet_type":
				funcName = "GetPacketType"
			case "endpoint_data_type":
				funcName = "GetEndpointDataType"
			case "message_type":
				funcName = "GetMessageType"
			}

			g.Annotate(m.GoIdent.GoName, m.Location)
			g.P("func (x *", m.GoIdent, ") ", funcName, "() ", enumTypeIdent, " {")
			g.P("return ", enumIdent.GoIdent)
			g.P("}")
			g.P()
			g.Unskip()
		}

		if ext.GetGeneratePacketHelpers() {
			gen.generatePacketHelpers(g, m)
		}

		if ext.GetGenerateEndpointMessageHelpers() {
			gen.generateEndpointHelpers(g, m)
		}

		if ext.GetGenerateErrorFn() {
			gen.generateErrorHelpers(g, m)
		}
	}

	gen.genParse(g, m, ext)
	gen.genFormatter(g, m, ext)
}

// TODO refactor
func (gen *Generator) generateEnum(g *protogen.GeneratedFile, enum *protogen.Enum) {

	ext := GetEnumExtensionFor(enum.Desc.Options())

	if ext != nil {

		switch ext.MessageOption {

		case "packet_type":
			g.Annotate(enum.GoIdent.GoName, enum.Location)
			g.P("func (", enum.GoIdent, ") GetPacketType(value string)", enum.GoIdent, "{")
			g.P("return ", enum.GoIdent, "(", enum.GoIdent, "_value[value])")
			g.P("}")
			g.P()
			g.Unskip()
		case "message_type":
			g.Annotate(enum.GoIdent.GoName, enum.Location)
			g.P("func (", enum.GoIdent, ") GetMessageType(value string)", enum.GoIdent, "{")
			g.P("return ", enum.GoIdent, "(", enum.GoIdent, "_value[value])")
			g.P("}")
			g.P()
			g.Unskip()
		case "endpoint_data_type":
			g.Annotate(enum.GoIdent.GoName, enum.Location)
			g.P("func (", enum.GoIdent, ") GetEndpointDataType(value string)", enum.GoIdent, "{")
			g.P("return ", enum.GoIdent, "(", enum.GoIdent, "_value[value])")
			g.P("}")
			g.P()
			g.Unskip()
		}
	}
}
