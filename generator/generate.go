package generator

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"log"
	"os"
	"strings"
	"unicode"
	"unicode/utf8"
)

// Object is an interface abstracting the abilities shared by enums, messages, extensions and imported objects.
type Object struct {
	protogen.GoIdent
	File *protogen.File
}

type Generator struct {
	plugin           *protogen.Plugin
	typeNameToObject map[string]Object
	parseFuncName    string
}

func NewGenerator(plugin *protogen.Plugin) *Generator {

	gen := &Generator{
		plugin:        plugin,
		parseFuncName: "Parse",
	}
	gen.BuildTypeNameMap()

	// log.Println("types", gen.typeNameToObject)

	return gen
}

// BuildTypeNameMap builds the map from fully qualified type names to objects.
// The key names for the map come from the input data, which puts a period at the beginning.
// It should be called after SetPackageNames and before GenerateAllFiles.
func (g *Generator) BuildTypeNameMap() {
	g.typeNameToObject = make(map[string]Object)
	for _, f := range g.plugin.Files {
		// The names in this loop are defined by the proto world, not us, so the
		// package name may be empty.  If so, the dotted package name of X will
		// be ".X"; otherwise it will be ".pkg.X".
		dottedPkg := "." + string(f.Proto.GetPackage())

		if dottedPkg != "." {
			dottedPkg += "."
		}

		for _, enum := range f.Enums {
			name := dottedPkg + enum.GoIdent.GoName

			log.Println("Add enum", name)

			g.typeNameToObject[name] = Object{
				GoIdent: enum.GoIdent,
				File:    f,
			}
		}
		for _, desc := range f.Messages {
			name := dottedPkg + desc.GoIdent.GoName
			log.Println("Add message", name, desc.GoIdent.String())

			g.typeNameToObject[name] = Object{
				GoIdent: desc.GoIdent,
				File:    f,
			}
		}
	}
}

// dottedSlice turns a sliced name into a dotted name.
func dottedSlice(elem []string) string { return strings.Join(elem, ".") }

// ObjectNamed, given a fully-qualified input type name as it appears in the input data,
// returns the descriptor for the message or enum with that name.
func (g *Generator) ObjectNamed(typeName string) Object {

	if !strings.HasPrefix(typeName, ".") {
		typeName = "." + typeName
	}
	log.Println("get", typeName)

	o, ok := g.typeNameToObject[typeName]
	if !ok {
		g.Fail("can't find object with type", typeName)
	}
	return o
}

const (
	//contextPkg         = protogen.GoImportPath("context")
	// encoderPackage         = protogen.GoImportPath("github.com/v8platform/encoder/ras")
	//errPkg             = protogen.GoImportPath("errors")

	deprecationComment = "// Deprecated: Do not use."
)

func (gen *Generator) GenerateFile(plugin *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {

	filename := file.GeneratedFilenamePrefix + "_ras.pb.go"

	// log.Printf("Processing %s", file.na)
	log.Printf("Generating %s\n", fmt.Sprintf("%s.ras.pb.go", file.GeneratedFilenamePrefix))

	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by github.com/v8platform/protoc-gen-go-ras. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the v8platform/protoc-gen-go-ras ras it is being compiled against.")
	// g.P("// ", contextPkg.Ident(""),  errPkg.Ident(""))
	g.P("// ", encoderPackage.Ident(""), ioPackage.Ident(""))
	g.P()

	for i, imps := 0, file.Desc.Imports(); i < imps.Len(); i++ {
		gen.genImport(plugin, g, file, imps.Get(i))
	}

	for _, message := range file.Messages {
		gen.genMessage(g, message)
	}

	return g
}

// Fail reports a problem and exits the program.
func (g *Generator) Fail(msgs ...string) {
	s := strings.Join(msgs, " ")
	log.Print("protoc-gen-go-ras: error:", s)
	os.Exit(1)
}

// Error reports a problem, including an error, and exits the program.
func (g *Generator) Error(err error, msgs ...string) {
	s := strings.Join(msgs, " ") + ":" + err.Error()
	log.Print("protoc-gen-go-ras: error:", s)
	os.Exit(1)
}

func (gen *Generator) genImport(plugin *protogen.Plugin, g *protogen.GeneratedFile, f *protogen.File, imp protoreflect.FileImport) {
	impFile, ok := plugin.FilesByPath[imp.Path()]
	if !ok {
		return
	}
	if impFile.GoImportPath == f.GoImportPath {
		// Don't generate imports or aliases for types in the same Go package.
		return
	}
	// Generate imports for all non-weak dependencies, even if they are not
	// referenced, because other code and tools depend on having the
	// full transitive closure of protocol buffer types in the binary.
	if !imp.IsWeak {
		g.Import(impFile.GoImportPath)
	}
	if !imp.IsPublic {
		return
	}

	// Generate public imports by generating the imported file, parsing it,
	// and extracting every symbol that should receive a forwarding declaration.
	impGen := gen.GenerateFile(plugin, impFile)
	impGen.Skip()
	b, err := impGen.Content()
	if err != nil {
		plugin.Error(err)
		return
	}
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", b, parser.ParseComments)
	if err != nil {
		plugin.Error(err)
		return
	}
	genForward := func(tok token.Token, name string, expr ast.Expr) {
		// Don't import unexported symbols.
		r, _ := utf8.DecodeRuneInString(name)
		if !unicode.IsUpper(r) {
			return
		}
		// Don't import the FileDescriptor.
		if name == impFile.GoDescriptorIdent.GoName {
			return
		}
		// Don't import decls referencing a symbol defined in another package.
		// i.e., don't import decls which are themselves public imports:
		//
		//	type T = somepackage.T
		if _, ok := expr.(*ast.SelectorExpr); ok {
			return
		}
		g.P(tok, " ", name, " = ", impFile.GoImportPath.Ident(name))
	}
	g.P("// Symbols defined in public import of ", imp.Path(), ".")
	g.P()
	for _, decl := range astFile.Decls {
		switch decl := decl.(type) {
		case *ast.GenDecl:
			for _, spec := range decl.Specs {
				switch spec := spec.(type) {
				case *ast.TypeSpec:
					genForward(decl.Tok, spec.Name.Name, spec.Type)
				case *ast.ValueSpec:
					for i, name := range spec.Names {
						var expr ast.Expr
						if i < len(spec.Values) {
							expr = spec.Values[i]
						}
						genForward(decl.Tok, name.Name, expr)
					}
				case *ast.ImportSpec:
				default:
					panic(fmt.Sprintf("can't generate forward for spec type %T", spec))
				}
			}
		}
	}
	g.P()
}

func (gen *Generator) genMessage(g *protogen.GeneratedFile, m *protogen.Message) {

	if m.Desc.IsMapEntry() {
		return
	}

	// Message type declaration.
	// g.Annotate(m.GoIdent.GoName, m.Location)
	// g.P("type ", StarlarkStructName(m.GoIdent), ` struct{`)
	// genMessageFields(gen, g, f, m)
	// g.P("}")
	// g.P()

	// genStarlarkProvider(g, m)
	gen.genUnmarshal(g, m)
}

func (gen *Generator) genUnmarshal(g *protogen.GeneratedFile, m *protogen.Message) {

	fields := getMessageFields(m)

	if len(fields) == 0 {
		return
	}

	g.P("func (x *", m.GoIdent, ") ", gen.parseFuncName, " (reader io.Reader, version int32) error {")
	g.P("if x == nil { return nil }")

	cVersion := int32(0)
	brackets := 0
	fields.Range(func(f field) bool {

		fVersion := f.Opts.GetVersion()

		if !(cVersion == fVersion) {

			if brackets > 0 {
				brackets--
				g.P("}")
			}
			g.P("if version >= ", fVersion, "{")
			brackets++
			cVersion = fVersion

		}

		gen.generateFieldParser(g, m, f)

		return true
	})

	if brackets > 0 {
		brackets--
		g.P("}")
	}

	g.P("return nil")
	g.P("}")
}

func (gen *Generator) genBytesParser(g *protogen.GeneratedFile, m *protogen.Message, f field, identifier string) {

	if f.Opts.GetSizeField() != 0 {
		g.P(identifier, " = make([]byte, x.Get", getMessageFields(m).FindByNumber(f.Opts.GetSizeField()).GoName, "())")
	}

	g.P("if err:= ", g.QualifiedGoIdent(parseBytes), "(reader,", identifier, "); err != nil {")
	g.P("return err")
	g.P("}")

}

func (gen *Generator) genEnumParser(g *protogen.GeneratedFile, m *protogen.Message, f field, identifier string) {

	//g.P("// decode ", f.Descriptor.Enum().FullName())
	//log.Println(f.Descriptor.Enum().FullName())

	enumName := gen.ObjectNamed(string(f.Descriptor.Enum().FullName())).GoIdent

	g.P("var val_", f.GoName, " int32")
	g.P("if err:= ", g.QualifiedGoIdent(f.Decoder), "(reader, ", "&val_", f.GoName, "); err != nil {")
	g.P("return err")
	g.P("}")
	g.P(identifier, " = ", enumName, "(val_", f.GoName, ")")

}

func (gen *Generator) genListParser(g *protogen.GeneratedFile, m *protogen.Message, f field, identifier string) {

	sizeFieldName := "size_" + f.GoName

	g.P("var ", sizeFieldName, " int")

	if f.Opts.GetSizeField() != 0 {
		g.P(sizeFieldName, " = x.Get", getMessageFields(m).FindByNumber(f.Opts.GetSizeField()).GoName, "()")
	} else {
		g.P("if err:= ", g.QualifiedGoIdent(parseSize), "(reader, &", sizeFieldName, "); err != nil {")
		g.P("return err")
		g.P("}")
	}

	g.P("for i := 0; i <", sizeFieldName, "; i++ {")

	gen.generateValueParser(g, m, f, "val", true)

	g.P(identifier, " = append("+identifier, ", val)")
	g.P("}")

}

func (gen *Generator) generateFieldParser(g *protogen.GeneratedFile, m *protogen.Message, f field) {

	identifier := "x." + f.GoName

	g.P("// decode ", identifier, " opts: "+f.Opts.String())

	switch {
	case f.Descriptor.IsList():
		gen.genListParser(g, m, f, identifier)
	case f.Descriptor.IsMap():
		gen.Fail("TODO generate map")
	default:
		gen.generateValueParser(g, m, f, identifier, false)
	}
}

func (gen *Generator) generateValueParser(g *protogen.GeneratedFile, m *protogen.Message, f field, identifier string, createVal bool) {

	switch f.Descriptor.Kind() {
	case protoreflect.BytesKind:
		gen.genBytesParser(g, m, f, identifier)
	case protoreflect.EnumKind:
		gen.genEnumParser(g, m, f, identifier)
	case protoreflect.MessageKind, protoreflect.GroupKind:
		gen.generateMessageParser(g, f, identifier, createVal)
	default:
		gen.generateSingularParser(g, f, identifier, createVal)
	}
}

func (gen *Generator) generateMessageParser(g *protogen.GeneratedFile, f field, identifier string, createVal bool) {

	valueName := string(f.Descriptor.Message().FullName())
	g.P(identifier, " := &", gen.ObjectNamed(valueName).GoIdent, "{}")
	g.P("if err:= ", identifier, ".", gen.parseFuncName, "(reader, version)", "; err != nil { return err }")
	g.P()

}

//
func (gen *Generator) generateSingularParser(g *protogen.GeneratedFile, f field, identifier string, createVal bool) {

	F := func(s protogen.GoIdent, goType string) {
		if createVal {
			g.P("var ", identifier, " "+goType)
		}
		g.P("if err:= ", g.QualifiedGoIdent(s), "(reader, &", identifier, "); err != nil { return err }")
	}

	decoder := f.Decoder

	switch f.Descriptor.Kind() {
	case protoreflect.BoolKind:
		F(decoder, "bool")
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind,
		protoreflect.Fixed32Kind, protoreflect.Sfixed32Kind:
		F(decoder, "int32")
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind,
		protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		F(decoder, "int64")
	case protoreflect.FloatKind:
		F(decoder, "float32")
	case protoreflect.DoubleKind:
		F(decoder, "float64")
	case protoreflect.StringKind:
		F(decoder, "string")
	default:
		gen.Fail("Unknown type decoder")
	}

}

//
// func namesListQuoteAndJoinByComma(fieldDesc protoreflect.FieldDescriptor) string {
// 	return `"` + strings.Join(namesList(fieldDesc), `", "`) + `"`
// }
//
// func namesList(fieldDesc protoreflect.FieldDescriptor) []string {
// 	result := make([]string, 1, 2)
//
// 	jsonName := fieldDesc.JSONName()
// 	result[0] = jsonName
//
// 	protoName := string(fieldDesc.Name())
// 	if protoName != jsonName {
// 		result = append(result, protoName)
// 	}
//
// 	return result
// }
