package generator

import (
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"strings"
)

type clientGenerator struct {
	*Generator
	gen  *protogen.Plugin
	file *protogen.File
	g    *protogen.GeneratedFile
}

// GenerateFileContent generates the gRPC service definitions, excluding the package statement.
func (m clientGenerator) GenerateFileContent() {
	if len(m.file.Services) == 0 {
		return
	}

	for _, service := range m.file.Services {
		if GetIsClientExtension(service.Desc.Options()) {
			m.genService(service)
		}
	}
}

func (m clientGenerator) genService(service *protogen.Service) {

	m.g.Unskip()

	m.genClientImpl(service)
	m.genClientConstructor(service)
	m.genClientDefinition(service)
	m.genDetectSupportedVersion(service)

	for _, method := range service.Methods {
		m.genMethodHandler(service, method)
	}
}

func (m clientGenerator) genHeader(packageName string) {
	m.g.P("// Code generated by protoc-gen-go-ras. DO NOT EDIT.")
	m.g.P()
	m.g.P("package ", packageName)
	m.g.P()
}
func (m clientGenerator) genClientImpl(service *protogen.Service) {

	m.g.P("type ", m.getClientServiceImp(service), " interface {")
	for _, method := range service.Methods {
		m.g.P("", method.GoName, "(ctx ", ctxPackage.Ident("Context"), ", req *", method.Input.GoIdent, ", opts ...interface{}) (*", method.Output.GoIdent, ", error)")
	}
	m.g.P("}")
	m.g.P()
	m.AddImpl(m.getClientServiceImp(service), m.file.GoImportPath)

	m.g.P("type Channel interface {")
	m.g.P("SendMsg(ctx ", ctxPackage.Ident("Context"), ", msg interface{}, opts ...interface{}) error")
	m.g.P("RecvMsg(ctx ", ctxPackage.Ident("Context"), ", msg interface{}, opts ...interface{}) error")
	m.g.P("}")
	m.g.P()
	m.g.P("type ", getClientImp(), " interface {")
	m.g.P("Invoke(ctx ", ctxPackage.Ident("Context"), ", needEndpoint bool, req interface{}, handler InvokeHandler, opts ...interface{}) (interface{}, error)")
	m.g.P("}")
	m.g.P("")
	m.g.P("type InvokeHandler func(ctx ", ctxPackage.Ident("Context"), ", channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error)")
	m.g.P("type Interceptor func(ctx ", ctxPackage.Ident("Context"), ", channel Channel, endpoint Endpoint, info *RequestInfo, req interface{}, handler InterceptorHandler) (interface{}, error)")
	m.g.P("type InterceptorHandler func(ctx ", ctxPackage.Ident("Context"), ", channel Channel, endpoint Endpoint, req interface{}) (interface{}, error)")
	m.g.P()
	m.g.P("type Endpoint interface {")
	m.g.P(" GetVersion() int32 ")
	m.g.P(" GetId() int32 ")
	m.g.P("}")
	m.g.P()

	m.AddImpl(m.getClientImp(), m.file.GoImportPath)

}

func (m clientGenerator) genClientConstructor(service *protogen.Service) {
	serviceName := m.getClientName(service)

	m.g.P("func New", serviceName, "(client ", getClientImp(), ") ", m.getClientServiceImp(service), "{")
	m.g.P("return ", unexport(serviceName), "{")
	m.g.P("cc: client,")
	m.g.P("}")
	m.g.P("}")

}

func (m clientGenerator) genClientDefinition(service *protogen.Service) {
	serviceName := m.getClientName(service)

	m.g.P("// ", serviceName, " is the client for RAS service.")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		m.g.P("//")
		m.g.P(deprecationComment)
	}
	m.g.Annotate(serviceName, service.Location)
	m.g.P("type ", unexport(serviceName), " struct {")
	m.g.P("cc ", getClientImp(), "")
	m.g.P("}")
	m.g.P()

	m.g.Annotate(serviceName, service.Location)
	m.g.P("type RequestInfo struct {")
	m.g.P("Method     string")
	m.g.P("FullMethod string")
	m.g.P("")
	m.g.P("}")
	m.g.P()
}

func (m clientGenerator) genDetectSupportedVersion(service *protogen.Service) {
	serviceName := m.getClientName(service)

	m.g.Annotate(serviceName, service.Location)
	m.g.P("var serviceVersions = []string{\"3.0\", \"4.0\", \"5.0\", \"6.0\", \"7.0\", \"8.0\", \"9.0\", \"10.0\"}")
	m.g.P()
	m.g.P("var re = ", regexpPackage.Ident("MustCompile"), "(`(?m)supported=(.*?)]`)")
	m.g.P()
	m.g.P("// DetectSupportedVersion func helpers detect supported version in EndpointFailureAck")
	m.g.P("func DetectSupportedVersion(err error) string {")
	m.g.P()
	m.g.P("fail, ok := err.(*", m.ObjectNamed("ras.protocol.v1.EndpointFailureAck").GoIdent, ")")
	m.g.P("if !ok { return \"\" }")
	m.g.P()
	m.g.P("if fail.Cause == nil { return \"\" }")
	m.g.P()
	m.g.P("matches := re.FindAllString(fail.Cause.Message, -1)")
	m.g.P()
	m.g.P("if len(matches) == 0 { return \"\" }")
	m.g.P()
	m.g.P("supported := matches[0]")
	m.g.P("for i := len(serviceVersions) - 1; i >= 0; i-- {")
	m.g.P("version := serviceVersions[i]")
	m.g.P("if ", stringsPackage.Ident("Contains"), "(supported, version) { return version }")
	m.g.P("}")
	m.g.P()
	m.g.P("return \"\"")
	m.g.P("}")
	m.g.P()
}

func (m clientGenerator) genMethodHandler(service *protogen.Service, method *protogen.Method) {

	protocolv1 := m.ObjectNamed(".ras.protocol.v1.EndpointOpen").GoImportPath

	m.g.P("func (x ", unexport(m.getClientName(service)), ") ", method.GoName, "(ctx ", ctxPackage.Ident("Context"), ", req *", method.Input.GoIdent, ", opts... interface{}) (*", method.Output.GoIdent, ", error) {")
	m.g.P("reply, err := x.cc.Invoke(ctx, false, req, ", m.getMethodHandlerName(method), ", opts...)")
	m.g.P("if err != nil { return nil, err }")
	m.g.P("return reply.(*", method.Output.GoIdent, "), nil")
	m.g.P("}")
	m.g.P()

	m.g.P("func ", m.getMethodHandlerName(method), "(ctx ", ctxPackage.Ident("Context"), ", channel Channel, endpoint Endpoint, req interface{}, interceptor Interceptor) (interface{}, error) {")
	m.g.P()
	m.g.P("if interceptor == nil {")
	m.g.P("reply := new(", method.Output.GoIdent, ")")
	if isEmptyPb(method.Output.Desc) {
		m.g.P("return reply, ", protocolv1.Ident("PacketChannelRequest"), "(ctx, channel, req.(*", method.Input.GoIdent, "), nil)")
	} else {
		m.g.P("return reply, ", protocolv1.Ident("PacketChannelRequest"), "(ctx, channel, req.(*", method.Input.GoIdent, "), reply)")
	}
	m.g.P("}")

	m.g.P("info := &RequestInfo {")
	m.g.P("Method : \"", method.GoName, "\",")
	m.g.P("FullMethod : \"/", method.Desc.Parent().FullName(), "/", method.GoName, "\",")
	m.g.P("}")
	m.g.P("")
	m.g.P("handler := func (ctx ", ctxPackage.Ident("Context"), ", cc Channel, endpoint Endpoint, req interface{}) (interface{}, error) {")
	m.g.P("reply := new(", method.Output.GoIdent, ")")
	if isEmptyPb(method.Output.Desc) {
		m.g.P("return reply, ", protocolv1.Ident("PacketChannelRequest"), "(ctx, cc, req.(*", method.Input.GoIdent, "), nil)")
	} else {
		m.g.P("return reply, ", protocolv1.Ident("PacketChannelRequest"), "(ctx, cc, req.(*", method.Input.GoIdent, "), reply)")
	}
	m.g.P("}")
	m.g.P("return interceptor(ctx, channel, endpoint, info, req, handler)")
	m.g.P("}")
	m.g.P()
}

func (m clientGenerator) getClientName(service *protogen.Service) string {
	return service.GoName
}

func (m clientGenerator) getClientImp() string {
	return getClientImp()
}

func getClientImp() string {
	return "Client"
}

func (m clientGenerator) getClientServiceImp(service *protogen.Service) string {
	return service.GoName
}

func (m clientGenerator) getMethodHandlerName(method *protogen.Method) string {
	return method.GoName + "Handler"
}

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }
