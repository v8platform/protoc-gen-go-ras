package generator

import (
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"strings"
)

const (
	osPackage          = protogen.GoImportPath("os")
	strConvPackage     = protogen.GoImportPath("strconv")
	contextPackage     = protogen.GoImportPath("context")
	protoPackage       = protogen.GoImportPath("github.com/golang/protobuf/proto")
	grpcPackage        = protogen.GoImportPath("google.golang.org/grpc")
	grpcHandlerPackage = protogen.GoImportPath("github.com/carvalhorr/protoc-gen-mock/grpchandler")
	netPackage         = protogen.GoImportPath("net")
	remotePackage      = protogen.GoImportPath("github.com/carvalhorr/protoc-gen-mock/remote")
	codesPackage       = protogen.GoImportPath("google.golang.org/grpc/codes")
	statusPackage      = protogen.GoImportPath("google.golang.org/grpc/status")
	bootstrapPackage   = protogen.GoImportPath("github.com/carvalhorr/protoc-gen-mock/bootstrap")
)

type clientGenerator struct {
	*Generator
	gen  *protogen.Plugin
	file *protogen.File
	g    *protogen.GeneratedFile
}

// GenerateFileContent generates the gRPC service definitions, excluding the package statement.
func (m clientGenerator) GenerateFileContent() {
	if len(m.file.Services) == 0 {
		return
	}

	for _, service := range m.file.Services {
		if GetIsClientExtensionFor(service.Desc.Options()) {
			m.genService(service)
		}
	}
}

func (m clientGenerator) genService(service *protogen.Service) {

	m.g.Unskip()

	m.genClientImpl(service)
	m.genClientConstructor(service)
	m.genClientDefinition(service)
	m.genClientOptionsDefinition(service)
	m.genDialMethodFunction(service)

	for _, method := range service.Methods {
		m.genMethodHandler(service, method)
	}
}

func (m clientGenerator) genHeader(packageName string) {
	m.g.P("// Code generated by protoc-gen-go-ras. DO NOT EDIT.")
	m.g.P()
	m.g.P("package ", packageName)
	m.g.P()
}
func (m clientGenerator) genClientImpl(service *protogen.Service) {

	m.g.P("type ", m.getClientImp(service), " interface {")
	for _, method := range service.Methods {
		m.g.P("", method.GoName, "(req *", method.Input.GoIdent, ") (resp *", method.Output.GoIdent, ", err error)")
	}
	m.g.P("}")

}
func (m clientGenerator) genClientConstructor(service *protogen.Service) {
	serviceName := m.getClientName(service)
	optionsName := m.getClientOptionsName(service)
	optionName := m.getClientOptionName(service)

	m.g.P("func New", serviceName, "(host string, opts... ", optionName, ") ", m.getClientImp(service), "{")
	m.g.P("options := &", optionsName, "{}")
	m.g.P("for _, opt := range opts {")
	m.g.P("opt(options)")
	m.g.P("}")
	m.g.P("return &", serviceName, "{")
	m.g.P("host: host,")
	m.g.P("Options: options,")
	m.g.P("}")
	m.g.P("}")

}

func (m clientGenerator) genClientDefinition(service *protogen.Service) {
	serviceName := m.getClientName(service)
	optionsName := m.getClientOptionsName(service)

	m.g.P("// ", serviceName, " is the client for RAS service.")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		m.g.P("//")
		m.g.P(deprecationComment)
	}
	m.g.Annotate(serviceName, service.Location)
	m.g.P("type ", serviceName, " struct {")
	m.g.P("*", optionsName, "")
	m.g.P("host string")
	m.g.P("conn ", netPackage.Ident("Conn"), "")
	m.g.P("}")
	m.g.P()
}

func (m clientGenerator) genClientOptionsDefinition(service *protogen.Service) {
	// Server registration.
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		m.g.P(deprecationComment)
	}
	optionName := m.getClientOptionName(service)
	optionsName := m.getClientOptionsName(service)
	m.g.P("type ", optionName, " func(*", optionsName, ")")
	m.g.P()
	m.g.P("type ", optionsName, " struct {")
	m.g.P("dialer *", netPackage.Ident("Dialer"), "")
	m.g.P("}")
	m.g.P()
	m.g.P("func WithDialer(dialer *", netPackage.Ident("Dialer"), ") ", optionName, " {")
	m.g.P("return func (o *", optionsName, ") { o.dialer = dialer }")
	m.g.P("}")

}

func (m clientGenerator) genDialMethodFunction(service *protogen.Service) {
	m.g.P("func (x *", m.getClientName(service), ") dial() error {")
	m.g.P("if x.conn != nil { return nil }")
	m.g.P("if _, err :=", netPackage.Ident("ResolveTCPAddr"), "(\"tcp\", x.host); err != nil { return err }")
	m.g.P()
	m.g.P("var err error")
	m.g.P("if x.dialer != nil { ")
	m.g.P("x.conn, err = x.dialer.Dial(\"tcp\", x.host)")
	m.g.P("return err")
	m.g.P("}")
	m.g.P("x.conn, err = ", netPackage.Ident("Dial"), "(\"tcp\", x.host)")
	m.g.P("return err")
	m.g.P("}")
	m.g.P()
}

func isEmptyPb(m protoreflect.MessageDescriptor) bool {
	return m.FullName() == "google.protobuf.Empty"
}
func (m clientGenerator) genMethodHandler(service *protogen.Service, method *protogen.Method) {
	ext := GetClientMethodExtensionFor(method.Desc.Options())

	m.g.P("func (x *", m.getClientName(service), ") ", method.GoName, "(req *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
	m.g.P("if err := x.dial(); err != nil { return nil, err }")
	if ext.NoPacketPack {
		m.g.P("// TODO convert to formatter")
		m.g.P("if err := req.", m.formatFuncName, "(x.conn, 0 ); err != nil { return nil, err }")
	} else {
		m.g.P("packet, err := ", method.Input.GoIdent.GoImportPath.Ident("NewPacket"), "(req)")
		m.g.P("if err != nil { return nil, err }")
		m.g.P("if _, err := packet.WriteTo(x.conn); err != nil { return nil, err }")
	}
	if isEmptyPb(method.Output.Desc) {
		m.g.P("return new(", method.Output.GoIdent, "), nil")
		m.g.P("}")
		return
	}
	m.g.P("if err := x.conn.SetReadDeadline(time.Now().Add(5 * ", timePackage.Ident("Second"), ")); err != nil { return nil, err }")
	m.g.P("ackPacket, err := ", method.Input.GoIdent.GoImportPath.Ident("NewPacket"), "(x.conn)")
	m.g.P("if err != nil { return nil, err }")
	m.g.P("resp := new(", method.Output.GoIdent, ")")
	m.g.P("return resp, ackPacket.Unpack(resp)")
	m.g.P("}")
	m.g.P()
}

func (m clientGenerator) getClientName(service *protogen.Service) string {
	return service.GoName
}

func (m clientGenerator) getClientImp(service *protogen.Service) string {
	return service.GoName + "Impl"
}

func (m clientGenerator) getClientOptionsName(service *protogen.Service) string {
	return "Options"
}

func (m clientGenerator) getClientOptionName(service *protogen.Service) string {
	return "Option"
}

func (m clientGenerator) getRemoteMockClientName(service *protogen.Service) string {
	return service.GoName + "RemoteMockClient"
}

func (m clientGenerator) getMockServerBaseInterfaceName(service *protogen.Service) string {
	return service.GoName + "Server"
}

func (m clientGenerator) getMockServiceDescriptorName(service *protogen.Service) string {
	return "_" + service.GoName + "_MockServiceDesc"
}

func unexport(s string) string { return strings.ToLower(s[:1]) + s[1:] }
