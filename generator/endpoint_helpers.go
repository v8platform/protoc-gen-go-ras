package generator

import (
	"google.golang.org/protobuf/compiler/protogen"
	"strings"
)

func (gen *Generator) generateEndpointMessageHelpers(g *protogen.GeneratedFile, m *protogen.Message) {

	endpointMessageDataTypeIdent := gen.EnumNamed("ENDPOINT_DATA_TYPE_MESSAGE").GoIdent
	messageDataIdent := gen.enumToObject["ENDPOINT_DATA_TYPE_MESSAGE"].GoIdent
	MessageTypeIdent := gen.EnumNamed("GET_AGENT_ADMINS_REQUEST").TypeIdent
	messageName := m.GoIdent.GoName
	messageFormatterName := messageName + "Formatter"
	messageParserName := messageName + "Parser"

	fields := getMessageFields(m)
	dataField := fields.FindByNumber(5)
	g.P("// Helpers generated by github.com/v8platform/protoc-gen-go-ras. DO NOT EDIT")
	g.P()
	g.P("type ", messageFormatterName, " interface {")
	g.P(" GetMessageType() ", g.QualifiedGoIdent(MessageTypeIdent))
	g.P(" ", gen.formatFuncName, "(writer io.Writer, version int32) error")
	g.P("}")
	g.P()
	g.P("type ", messageParserName, " interface {")
	g.P(" GetMessageType() ", g.QualifiedGoIdent(MessageTypeIdent))
	g.P(" ", gen.parseFuncName, "(reader io.Reader, version int32) error")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func New", m.GoIdent.GoName, "(endpoint EndpointImpl, message ", messageFormatterName, ") (*", m.GoIdent, ", error){")
	g.P("buf := &", bytesBuffer, "{}")
	g.P("if err := message.", gen.formatFuncName, "(buf, endpoint.GetVersion()); err != nil { return nil, err }")
	g.P("return &", m.GoIdent, "{")
	g.P("Type: ", endpointMessageDataTypeIdent, ",")
	g.P("Format: endpoint.GetFormat(),")
	g.P("EndpointId: endpoint.GetId(),")
	g.P("Data: &", dataField.Oneof.GoIdent, "{")
	g.P(dataField.Oneof.GoName, ": &", messageDataIdent, "{")
	g.P("Bytes: buf.Bytes(),")
	g.P("Type: message.GetMessageType(),")
	g.P("},")
	g.P("},")
	g.P("}, nil")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func (x *", m.GoIdent, ") Unpack(into ", messageParserName, ") error {")
	g.P("if x.GetType() != into.GetPacketType() {")
	g.P("return ", fmtErrorf, "(\"unpack type no equal packet type. Has %s want %s\", into.GetPacketType(), x.GetType())")
	g.P("}")
	g.P("buf := ", bytesNewBuffer, "(x.Data)")
	g.P("return into.Parse(buf, 0)")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func (x *", m.GoIdent, ") UnpackNew() (interface{}, error) {")
	g.P("var into interface{}")
	g.P("switch x.GetType() {")

	for enumName, object := range gen.enumToObject {
		if strings.HasPrefix(enumName, "MESSAGE_TYPE") {
			enumIdent := gen.EnumNamed(enumName)
			g.P("// type ", enumIdent.GoName, " cast ", object.GoName)
			g.P("case ", enumIdent.GoIdent, " :")
			g.P("into = &", object.GoIdent, "{}")
		}
	}

	g.P("default: ")
	g.P("return nil, ", fmtErrorf, "(\"unknown unpack type %s\",  x.GetType())")
	g.P("}")
	g.P("buf := ", bytesNewBuffer, "(x.Data)")
	g.P("parser := into.(", messageParserName, ")")
	g.P("if err := parser.Parse(buf, 0); err != nil { return nil, err }")
	g.P("if err, ok := into.(error); ok { return nil, err }")
	g.P("return into, nil")
	g.P("}")
	g.P()
	g.Unskip()
}

func (gen *Generator) generateEndpointHelpers(g *protogen.GeneratedFile, m *protogen.Message) {

	//endpointMessageDataTypeIdent := gen.EnumNamed("ENDPOINT_DATA_TYPE_MESSAGE").GoIdent
	endpointMessageIdent := gen.enumToObject["PACKET_TYPE_ENDPOINT_MESSAGE"].GoIdent
	//MessageTypeIdent := gen.EnumNamed("GET_AGENT_ADMINS_REQUEST").TypeIdent
	endpointName := m.GoIdent.GoName
	endpointImplName := endpointName + "Impl"
	messageFormatterName := endpointMessageIdent.GoName + "Formatter"

	g.P("// Helpers generated by github.com/v8platform/protoc-gen-go-ras. DO NOT EDIT")
	g.P()
	g.P("type ", endpointImplName, " interface {")
	g.P(" GetVersion() int32 ")
	g.P(" GetId() int32 ")
	g.P(" GetService() string ")
	g.P(" GetFormat() int32 ")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func New", m.GoIdent.GoName, "(id int32, version int32) *", m.GoIdent, "{")
	g.P("return &", m.GoIdent, "{")
	g.P("Service: \"v8.service.Admin.Cluster\",")
	g.P("Version: version,")
	g.P("Id: id,")
	g.P("Format: ", codecVersion, "()}")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func (x *", m.GoIdent, ") NewMessage(message ", messageFormatterName, ") (*", endpointMessageIdent, ", error) {")
	g.P("return New", endpointMessageIdent.GoName, "(x, message)")
	g.P("}")

	//g.Annotate(m.GoIdent.GoName, m.Location)
	//g.P("func (x *", m.GoIdent, ") Unpack(into ", messageParserName, ") error {")
	//g.P("if x.GetType() != into.GetPacketType() {")
	//g.P("return ", fmtErrorf, "(\"unpack type no equal packet type. Has %s want %s\", into.GetPacketType(), x.GetType())")
	//g.P("}")
	//g.P("buf := ", bytesNewBuffer, "(x.Data)")
	//g.P("return into.Parse(buf, 0)")
	//g.P("}")
	//g.P()
	//g.Annotate(m.GoIdent.GoName, m.Location)
	//g.P("func (x *", m.GoIdent, ") UnpackNew() (interface{}, error) {")
	//g.P("var into interface{}")
	//g.P("switch x.GetType() {")
	//
	//for enumName, object := range gen.enumToObject {
	//	if strings.HasPrefix(enumName, "MESSAGE_TYPE") {
	//		enumIdent := gen.EnumNamed(enumName)
	//		g.P("// type ", enumIdent.GoName, " cast ", object.GoName)
	//		g.P("case ", enumIdent.GoIdent, " :")
	//		g.P("into = &", object.GoIdent, "{}")
	//	}
	//}
	//
	//g.P("default: ")
	//g.P("return nil, ", fmtErrorf, "(\"unknown unpack type %s\",  x.GetType())")
	//g.P("}")
	//g.P("buf := ", bytesNewBuffer, "(x.Data)")
	//g.P("parser := into.(", messageParserName, ")")
	//g.P("if err := parser.Parse(buf, 0); err != nil { return nil, err }")
	//g.P("if err, ok := into.(error); ok { return nil, err }")
	//g.P("return into, nil")
	//g.P("}")
	//g.P()
	g.Unskip()
}
