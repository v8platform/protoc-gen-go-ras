package generator

import (
	"google.golang.org/protobuf/compiler/protogen"
	"strings"
)

func (gen *Generator) generateEndpointHelpers(g *protogen.GeneratedFile, m *protogen.Message) {

	endpointMessageDataTypeIdent := gen.EnumNamed("ENDPOINT_DATA_TYPE_MESSAGE").GoIdent
	messageDataIdent := gen.enumToObject["ENDPOINT_DATA_TYPE_MESSAGE"].GoIdent
	MessageTypeIdent := gen.EnumNamed("GET_AGENT_ADMINS_REQUEST").TypeIdent
	messageName := m.GoIdent.GoName
	messageFormatterName := messageName + "Formatter"
	messageParserName := messageName + "Parser"

	g.P("// Helpers generated by github.com/v8platform/protoc-gen-go-ras. DO NOT EDIT")
	g.P()
	g.P("type ", messageFormatterName, " interface {")
	g.P(" GetMessageType() ", g.QualifiedGoIdent(MessageTypeIdent))
	g.P(" ", gen.formatFuncName, "(writer io.Writer, version int32) error")
	g.P("}")
	g.P()
	g.P("type ", messageParserName, " interface {")
	g.P(" GetMessageType() ", g.QualifiedGoIdent(MessageTypeIdent))
	g.P(" ", gen.parseFuncName, "(reader io.Reader, version int32) error")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func New", m.GoIdent.GoName, "(message ", messageFormatterName, ", version int32) (*", m.GoIdent, ", error){")
	g.P("buf := &", bytesBuffer, "{}")
	g.P("if err := message.", gen.formatFuncName, "(buf, version); err != nil { return nil, err }")
	g.P("var result ", m.GoIdent, "")
	g.P("result.Type = ", endpointMessageDataTypeIdent)
	g.P("messageData := ", messageDataIdent, "{}")
	g.P("messageData.Bytes = buf.Bytes()")
	g.P("messageData.Type = message.GetMessageType()")
	g.P("result.Data = &messageData")
	g.P("return &result,  nil")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func (x *", m.GoIdent, ") Unpack(into ", messageParserName, ") error {")
	g.P("if x.GetType() != into.GetPacketType() {")
	g.P("return ", fmtErrorf, "(\"unpack type no equal packet type. Has %s want %s\", into.GetPacketType(), x.GetType())")
	g.P("}")
	g.P("buf := ", bytesNewBuffer, "(x.Data)")
	g.P("return into.Parse(buf, 0)")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func (x *", m.GoIdent, ") UnpackNew() (interface{}, error) {")
	g.P("var into interface{}")
	g.P("switch x.GetType() {")

	for enumName, object := range gen.enumToObject {
		if strings.HasPrefix(enumName, "MESSAGE_TYPE") {
			enumIdent := gen.EnumNamed(enumName)
			g.P("// type ", enumIdent.GoName, " cast ", object.GoName)
			g.P("case ", enumIdent.GoIdent, " :")
			g.P("into = &", object.GoIdent, "{}")
		}
	}

	g.P("default: ")
	g.P("return nil, ", fmtErrorf, "(\"unknown unpack type %s\",  x.GetType())")
	g.P("}")
	g.P("buf := ", bytesNewBuffer, "(x.Data)")
	g.P("parser := into.(", messageParserName, ")")
	g.P("if err := parser.Parse(buf, 0); err != nil { return nil, err }")
	g.P("if err, ok := into.(error); ok { return nil, err }")
	g.P("return into, nil")
	g.P("}")
	g.P()
	g.Unskip()
}
