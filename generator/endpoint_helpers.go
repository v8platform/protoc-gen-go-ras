package generator

import (
	"google.golang.org/protobuf/compiler/protogen"
)

func (gen *Generator) generateEndpointMessageHelpers(g *protogen.GeneratedFile, m *protogen.Message) {

	endpointMessageDataTypeIdent := gen.EnumNamed("ENDPOINT_DATA_TYPE_MESSAGE").GoIdent
	messageDataIdent := gen.idxMessageByEnumValue["ENDPOINT_DATA_TYPE_MESSAGE"].GoIdent
	_ = gen.idxMessageByEnumValue["ENDPOINT_DATA_TYPE_VOID_MESSAGE"].GoIdent
	_ = gen.idxMessageByEnumValue["ENDPOINT_DATA_TYPE_EXCEPTION"].GoIdent

	messageDataEnumIdent := gen.EnumNamed("ENDPOINT_DATA_TYPE_MESSAGE").GoIdent
	voidMessageEnumIdent := gen.EnumNamed("ENDPOINT_DATA_TYPE_VOID_MESSAGE").GoIdent
	exceptionMessagEnumeIdent := gen.EnumNamed("ENDPOINT_DATA_TYPE_EXCEPTION").GoIdent

	MessageTypeIdent := gen.KnownTypes.EnumMessageType.GoIdent

	messageName := m.GoIdent.GoName
	messageFormatterName := messageName + "Formatter"
	messageParserName := messageName + "Parser"

	fields := getMessageFields(m)
	dataField := fields.FindByNumber(5)
	g.P("// Helpers generated by github.com/v8platform/protoc-gen-go-ras. DO NOT EDIT")
	g.P()
	g.P("type ", messageFormatterName, " interface {")
	g.P(" GetMessageType() ", MessageTypeIdent)
	g.P(" ", gen.formatFuncName, "(writer io.Writer, version int32) error")
	g.P("}")
	g.P()
	g.P("type ", messageParserName, " interface {")
	g.P(" GetMessageType() ", MessageTypeIdent)
	g.P(" ", gen.parseFuncName, "(reader io.Reader, version int32) error")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func New", m.GoIdent.GoName, "(endpoint ", gen.KnownTypes.EndpointImpl(), ", message ", messageFormatterName, ") (*", m.GoIdent, ", error){")
	g.P("buf := &", bytesBuffer, "{}")
	g.P("if err := message.", gen.formatFuncName, "(buf, endpoint.GetVersion()); err != nil { return nil, err }")
	g.P("return &", m.GoIdent, "{")
	g.P("Type: ", endpointMessageDataTypeIdent, ",")
	g.P("Format: endpoint.GetFormat(),")
	g.P("EndpointId: endpoint.GetId(),")
	g.P("Data: &", dataField.Oneof.GoIdent, "{")
	g.P(dataField.Oneof.GoName, ": &", messageDataIdent, "{")
	g.P("Bytes: buf.Bytes(),")
	g.P("Type: message.GetMessageType(),")
	g.P("},")
	g.P("},")
	g.P("}, nil")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func (x *", m.GoIdent, ") Unpack(endpoint ", gen.KnownTypes.EndpointImpl(), ", into ", messageParserName, ") error {")
	g.P("switch x.GetType() {")
	g.P("case ", messageDataEnumIdent, ":")
	g.P("buf := ", bytesNewBuffer, "(x.GetMessage().GetBytes())")
	g.P("if err := into.", gen.parseFuncName, "(buf, endpoint.GetVersion()); err != nil { return err }")
	g.P("return nil ")
	g.P("case ", voidMessageEnumIdent, ":")
	g.P("return nil ")
	g.P("case ", exceptionMessagEnumeIdent, ":")
	g.P("return x.GetFailure()")
	g.P("default:")
	g.P("return ", fmtErrorf, "(\"unknown message type <%s>\", x.GetType())")
	g.P("}")
	g.P("}")
	g.P()
	// g.Annotate(m.GoIdent.GoName, m.Location)
	// g.P("func (x *", m.GoIdent, ") UnpackNew() (interface{}, error) {")
	// g.P("var into interface{}")
	// g.P("switch x.GetType() {")
	//
	// for enumName, object := range gen.enumToObject {
	// 	if strings.HasPrefix(enumName, "MESSAGE_TYPE") {
	// 		enumIdent := gen.EnumNamed(enumName)
	// 		g.P("// type ", enumIdent.GoName, " cast ", object.GoName)
	// 		g.P("case ", enumIdent.GoIdent, " :")
	// 		g.P("into = &", object.GoIdent, "{}")
	// 	}
	// }
	//
	// g.P("default: ")
	// g.P("return nil, ", fmtErrorf, "(\"unknown unpack type %s\",  x.GetType())")
	// g.P("}")
	// g.P("buf := ", bytesNewBuffer, "(x.Data)")
	// g.P("parser := into.(", messageParserName, ")")
	// g.P("if err := parser.Parse(buf, 0); err != nil { return nil, err }")
	// g.P("if err, ok := into.(error); ok { return nil, err }")
	// g.P("return into, nil")
	// g.P("}")
	// g.P()
	g.Unskip()
}

func (gen *Generator) generateEndpointHelpers(g *protogen.GeneratedFile, m *protogen.Message) {

	//endpointMessageDataTypeIdent := gen.EnumNamed("ENDPOINT_DATA_TYPE_MESSAGE").GoIdent
	endpointMessageIdent := gen.KnownTypes.PacketEndpointMessageType.GoIdent
	//MessageTypeIdent := gen.EnumNamed("GET_AGENT_ADMINS_REQUEST").TypeIdent
	endpointName := m.GoIdent.GoName
	endpointImplName := endpointName + "Impl"
	messageFormatterName := endpointMessageIdent.GoName + "Formatter"

	g.P("// Helpers generated by github.com/v8platform/protoc-gen-go-ras. DO NOT EDIT")
	g.P()
	g.P("type ", endpointImplName, " interface {")
	g.P(" GetVersion() int32 ")
	g.P(" GetId() int32 ")
	g.P(" GetService() string ")
	g.P(" GetFormat() int32 ")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func New", m.GoIdent.GoName, "(id int32, version int32) *", m.GoIdent, "{")
	g.P("return &", m.GoIdent, "{")
	g.P("Service: \"v8.service.Admin.Cluster\",")
	g.P("Version: version,")
	g.P("Id: id,")
	g.P("Format: ", codecVersion, "()}")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func (x *", m.GoIdent, ") NewMessage(data interface{}) (*", endpointMessageIdent, ", error) {")
	g.P("switch typed := data.(type) {")
	g.P("case ", ioReader, ":")
	g.P("packet, err := New", gen.idxMessage["Packet"].GoIdent, "(data)")
	g.P("if err != nil { return nil, err }")
	g.P("var message ", endpointMessageIdent, "")
	g.P("if err := packet.Unpack(&message); err != nil { return nil, err }")
	g.P("return &message, nil")
	g.P("case ", messageFormatterName, ": ")
	g.P("return New", endpointMessageIdent.GoName, "(x, typed)")
	g.P("default:")
	g.P("return nil, ", fmtErrorf, "(\"unknown type <%T> to create new message\", typed)")
	g.P("}")
	g.P("}")

	//g.Annotate(m.GoIdent.GoName, m.Location)
	//g.P("func (x *", m.GoIdent, ") Unpack(into ", messageParserName, ") error {")
	//g.P("if x.GetType() != into.GetPacketType() {")
	//g.P("return ", fmtErrorf, "(\"unpack type no equal packet type. Has %s want %s\", into.GetPacketType(), x.GetType())")
	//g.P("}")
	//g.P("buf := ", bytesNewBuffer, "(x.Data)")
	//g.P("return into.Parse(buf, 0)")
	//g.P("}")
	//g.P()
	//g.Annotate(m.GoIdent.GoName, m.Location)
	//g.P("func (x *", m.GoIdent, ") UnpackNew() (interface{}, error) {")
	//g.P("var into interface{}")
	//g.P("switch x.GetType() {")
	//
	//for enumName, object := range gen.enumToObject {
	//	if strings.HasPrefix(enumName, "MESSAGE_TYPE") {
	//		enumIdent := gen.EnumNamed(enumName)
	//		g.P("// type ", enumIdent.GoName, " cast ", object.GoName)
	//		g.P("case ", enumIdent.GoIdent, " :")
	//		g.P("into = &", object.GoIdent, "{}")
	//	}
	//}
	//
	//g.P("default: ")
	//g.P("return nil, ", fmtErrorf, "(\"unknown unpack type %s\",  x.GetType())")
	//g.P("}")
	//g.P("buf := ", bytesNewBuffer, "(x.Data)")
	//g.P("parser := into.(", messageParserName, ")")
	//g.P("if err := parser.Parse(buf, 0); err != nil { return nil, err }")
	//g.P("if err, ok := into.(error); ok { return nil, err }")
	//g.P("return into, nil")
	//g.P("}")
	//g.P()
	g.Unskip()
}
