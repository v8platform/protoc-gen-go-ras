package generator

import (
	"google.golang.org/protobuf/compiler/protogen"
	"strings"
)

func (gen *Generator) generatePacketHelpers(g *protogen.GeneratedFile, m *protogen.Message) {

	packetTypeIdent := gen.KnownTypes.EnumPacketType.GoIdent
	messageName := m.GoIdent.GoName + "Message"
	messageFormatterName := messageName + "Formatter"
	messageParserName := messageName + "Parser"

	g.P("// Helpers generated by github.com/v8platform/protoc-gen-go-ras. DO NOT EDIT")
	g.P("type ", messageName, " interface {")
	g.P(" ", messageFormatterName)
	g.P(" ", messageParserName)
	g.P("}")
	g.P()
	g.P("type ", messageFormatterName, " interface {")
	g.P(" GetPacketType() ", g.QualifiedGoIdent(packetTypeIdent))
	g.P(" ", gen.formatFuncName, "(writer io.Writer, version int32) error")
	g.P("}")
	g.P()
	g.P("type ", messageParserName, " interface {")
	g.P(" GetPacketType() ", g.QualifiedGoIdent(packetTypeIdent))
	g.P(" ", gen.parseFuncName, "(reader io.Reader, version int32) error")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func New", m.GoIdent.GoName, "(message interface{}) (*", m.GoIdent, ", error){")
	g.P("var packet ", m.GoIdent, "")
	g.P("switch typed := message.(type) {")
	g.P("case ", ioReader, ":")
	g.P("if err := packet.", gen.parseFuncName, "(typed, 0); err != nil { return nil, err }")
	g.P("case ", messageFormatterName, ": ")
	g.P("buf := &", bytesBuffer, "{}")
	g.P("if err := typed.", gen.formatFuncName, "(buf, 0); err != nil { return nil, err }")
	g.P("packet.Type = typed.GetPacketType()")
	g.P("packet.Data = buf.Bytes()")
	g.P("packet.Size = int32(len(packet.Data))")
	g.P("default:")
	g.P("return nil, ", fmtErrorf, "(\"unknown type <%T> to get new packet\", typed)")
	g.P("}")
	g.P("return &packet,  nil")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func (x *", m.GoIdent, ") Unpack(into ", messageParserName, ") error {")
	g.P("switch x.GetType() {")
	g.P("case into.GetPacketType():")
	g.P("buf := ", bytesNewBuffer, "(x.Data)")
	g.P("return into.Parse(buf, 0)")
	g.P("default:")
	g.P("if _, err := x.UnpackNew(); err != nil { return err}")
	g.P("return ", fmtErrorf, "(\"unpack type no equal packet type. Has %s want %s\", x.GetType(), into.GetPacketType())")
	g.P("}")
	g.P("}")
	g.P()
	g.Annotate(m.GoIdent.GoName, m.Location)
	g.P("func (x *", m.GoIdent, ") UnpackNew() (interface{}, error) {")
	g.P("var into interface{}")
	g.P("switch x.GetType() {")

	for enumName, objectValue := range gen.idxMessageByEnumValue {
		if strings.HasPrefix(enumName, "PACKET_TYPE") {
			enumIdent := gen.EnumNamed(enumName)
			g.P("// type ", enumIdent.GoIdent, " cast ", objectValue.GoIdent)
			g.P("case ", enumIdent.GoIdent, " :")
			g.P("into = &", objectValue.GoIdent, "{}")
		}
	}

	g.P("default: ")
	g.P("return nil, ", fmtErrorf, "(\"unknown unpack type %s\",  x.GetType())")
	g.P("}")
	g.P("buf := ", bytesNewBuffer, "(x.Data)")
	g.P("parser := into.(", messageParserName, ")")
	g.P("if err := parser.Parse(buf, 0); err != nil { return nil, err }")
	g.P("if err, ok := into.(error); ok { return nil, err }")
	g.P("return into, nil")
	g.P("}")
	g.P()
	g.Unskip()
}
